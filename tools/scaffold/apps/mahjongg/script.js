

var MahjonggLayouts = {
	standard144: [
			{ x: 2, y:14, z:0}, { x: 4, y:14, z:0}, { x: 6, y:14, z:0}, { x: 8, y:14, z:0}, { x: 10, y:14, z:0}, { x: 12, y:14, z:0}, { x: 14, y:14, z:0}, { x: 16, y:14, z:0}, { x: 18, y:14, z:0}, { x: 20, y:14, z:0}, { x: 22, y:14, z:0}, { x: 24, y:14, z:0},
			{ x: 6, y:12, z:0}, { x: 8, y:12, z:0}, { x: 10, y:12, z:0}, { x: 12, y:12, z:0}, { x: 14, y:12, z:0}, { x: 16, y:12, z:0}, { x: 18, y:12, z:0}, { x: 20, y:12, z:0},
			{ x: 4, y:10, z:0}, { x: 6, y:10, z:0}, { x: 8, y:10, z:0}, { x: 10, y:10, z:0}, { x: 12, y:10, z:0}, { x: 14, y:10, z:0}, { x: 16, y:10, z:0}, { x: 18, y:10, z:0}, { x: 20, y:10, z:0}, { x: 22, y:10, z:0},
			{ x: 0, y:7, z:0},
			{ x: 2, y:8, z:0}, { x: 4, y:8, z:0}, { x: 6, y:8, z:0}, { x: 8, y:8, z:0}, { x: 10, y:8, z:0}, { x: 12, y:8, z:0}, { x: 14, y:8, z:0}, { x: 16, y:8, z:0}, { x: 18, y:8, z:0}, { x: 20, y:8, z:0}, { x: 22, y:8, z:0}, { x: 24, y:8, z:0},
			{ x: 2, y:6, z:0}, { x: 4, y:6, z:0}, { x: 6, y:6, z:0}, { x: 8, y:6, z:0}, { x: 10, y:6, z:0}, { x: 12, y:6, z:0}, { x: 14, y:6, z:0}, { x: 16, y:6, z:0}, { x: 18, y:6, z:0}, { x: 20, y:6, z:0}, { x: 22, y:6, z:0}, { x: 24, y:6, z:0},
		    { x: 26, y:7, z:0}, { x: 28, y:7, z:0},
			{ x: 4, y:4, z:0}, { x: 6, y:4, z:0}, { x: 8, y:4, z:0}, { x: 10, y:4, z:0}, { x: 12, y:4, z:0}, { x: 14, y:4, z:0}, { x: 16, y:4, z:0}, { x: 18, y:4, z:0}, { x: 20, y:4, z:0}, { x: 22, y:4, z:0},
			{ x: 6, y:2, z:0}, { x: 8, y:2, z:0}, { x: 10, y:2, z:0}, { x: 12, y:2, z:0}, { x: 14, y:2, z:0}, { x: 16, y:2, z:0}, { x: 18, y:2, z:0}, { x: 20, y:2, z:0},
			{ x: 2, y:0, z:0}, { x: 4, y:0, z:0}, { x: 6, y:0, z:0}, { x: 8, y:0, z:0}, { x: 10, y:0, z:0}, { x: 12, y:0, z:0}, { x: 14, y:0, z:0}, { x: 16, y:0, z:0}, { x: 18, y:0, z:0}, { x: 20, y:0, z:0}, { x: 22, y:0, z:0}, { x: 24, y:0, z:0},

			{ x: 8, y:12, z:1}, { x: 10, y:12, z:1}, { x: 12, y:12, z:1}, { x: 14, y:12, z:1}, { x: 16, y:12, z:1}, { x: 18, y:12, z:1},
			{ x: 8, y:10, z:1}, { x: 10, y:10, z:1}, { x: 12, y:10, z:1}, { x: 14, y:10, z:1}, { x: 16, y:10, z:1}, { x: 18, y:10, z:1},
			{ x: 8, y:8, z:1}, { x: 10, y:8, z:1}, { x: 12, y:8, z:1}, { x: 14, y:8, z:1}, { x: 16, y:8, z:1}, { x: 18, y:8, z:1},
			{ x: 8, y:6, z:1}, { x: 10, y:6, z:1}, { x: 12, y:6, z:1}, { x: 14, y:6, z:1}, { x: 16, y:6, z:1}, { x: 18, y:6, z:1},
			{ x: 8, y:4, z:1}, { x: 10, y:4, z:1}, { x: 12, y:4, z:1}, { x: 14, y:4, z:1}, { x: 16, y:4, z:1}, { x: 18, y:4, z:1},
			{ x: 8, y:2, z:1}, { x: 10, y:2, z:1}, { x: 12, y:2, z:1}, { x: 14, y:2, z:1}, { x: 16, y:2, z:1}, { x: 18, y:2, z:1},

			{ x: 10, y:10, z:2}, { x: 12, y:10, z:2}, { x: 14, y:10, z:2}, { x: 16, y:10, z:2},
			{ x: 10, y:8, z:2}, { x: 12, y:8, z:2}, { x: 14, y:8, z:2}, { x: 16, y:8, z:2},
			{ x: 10, y:6, z:2}, { x: 12, y:6, z:2}, { x: 14, y:6, z:2}, { x: 16, y:6, z:2},
			{ x: 10, y:4, z:2}, { x: 12, y:4, z:2}, { x: 14, y:4, z:2}, { x: 16, y:4, z:2},

			{ x: 12, y:8, z:3}, { x: 14, y:8, z:3},
			{ x: 12, y:6, z:3}, { x: 14, y:6, z:3},

			{ x: 13, y:7, z:4}
		]
}

var MahjonggTileset = {
	standard: {
		tileTypes: ["bamboo", "man", "pin", "wind", "dragon", "flower", "season"],

		tiles: {
			"bamboo": {
				"icons": ["bamboo1.png", "bamboo2.png", "bamboo3.png", "bamboo4.png", "bamboo5.png", "bamboo6.png", "bamboo7.png", "bamboo8.png", "bamboo9.png"],
				"countInSet": 4,
				"matchesWithAnother": false
			},
			"man": {
				"icons": ["man1.png", "man2.png", "man3.png", "man4.png", "man5.png", "man6.png", "man7.png", "man8.png", "man9.png"],
				"countInSet": 4,
				"matchesWithAnother": false
			},
			"pin": {
				"icons": ["pin1.png", "pin2.png", "pin3.png", "pin4.png", "pin5.png", "pin6.png", "pin7.png", "pin8.png", "pin9.png"],
				"countInSet": 4,
				"matchesWithAnother": false
			},
			"wind": {
				"icons": ["wind-east.png", "wind-north.png", "wind-south.png", "wind-west.png"],
				"countInSet": 4,
				"matchesWithAnother": false
			},
			"dragon": {
				"icons": ["dragon-chun.png", "dragon-green.png", "dragon-haku.png"],
				"countInSet": 4,
				"matchesWithAnother": false
			},
			"flower": {
				"icons": ["flower-bamboo.png", "flower-chrysanthemum.png", "flower-orchid.png", "flower-plum.png"],
				"countInSet": 1,
				"matchesWithAnother": true
			},
			"season": {
				"icons": ["season-autumn.png", "season-spring.png", "season-summer.png", "season-winter.png"],
				"countInSet": 1,
				"matchesWithAnother": true
			}
		},

	}
}

var MahjonggTileWidget = GroupWidget.extend({
    constructor: function(mahjongg, type, index, x, y, z) {
        this.base();
	    var k = 1000/1280.0;
	    var xx = (42*x - 7*z);
	    var yy = (64*y + 14*z);
	    var imgname = mahjongg.tiles[type].icons[index];
        var bordr = new ImageWidget(mahjongg.tilesetBaseUrl + "/" + "mahjongg-border.png", 90 * k, 140 * k);
        bordr.setPosition(xx * k, 100 + (yy-6) * k);
        var img = new ImageWidget(mahjongg.tilesetBaseUrl + "/" + imgname, 84 * k, 128 * k);
        img.setPosition(xx * k, 100 + yy * k);
        var rect = new RectWidget(84 * k, 128 * k, 8);
        rect.setPosition(xx * k, 100 + yy * k);
        this.tileStyle = {"fill": mahjongg.layersColors[z], "stroke": "none", "opacity": 1.0};
        this.overlay = rect;
        this.clickable = new Clickable(img);
        this.addChild(img);
        this.addChild(rect);
        this.addChild(this.clickable);
        this.setDefaultStyle();
	},
	setDefaultStyle: function() {
        this.overlay.setStyle(this.tileStyle);
	},
	setSelectedStyle: function() {
        this.overlay.setStyle({"fill":"rgba(0,255,0,0.4)", "opacity":1.0});
	},
	setNonmatchedStyle: function() {
        this.overlay.setStyle({"fill":"rgba(255,0,0,0.4)", "opacity":1.0});
	}
});


var Mahjongg = TimedGame.extend({

	// 144 tiles
	// bamboo: 9 types * 4 = 36
	// wheels: 9 types * 4 = 36
	// numbers: 9 types * 4 = 36
	// -- 108
	// 4 winds: 4 types, 4 of each = 16
	// 3 dragons, 4 of each = 12
	// 4 flowers, 1 of each, each matches each other = 4
	// 4 seasons, 1 of each, each matches each other = 4

	defaultOptions: {
		layout: MahjonggLayouts.standard144,
		tileset: MahjonggTileset.standard,
		highlightDuration: 1000,
		boardDiv: "board2",
		layersColors: [
			"rgba(255,255,255,0)",
			"rgba(255,0,255,0.25)",
			"rgba(255,255,0,0.25)",
			"rgba(0,255,255,0.25)",
			"rgba(255,0,0,0.25)"
		]
	},

	constructor: function(config) {
        this.base(config);
		var o = this.defaultOptions;
		this.opts = o;

		this.highlightDuration = o.highlightDuration || 1000;
		var layout = o.layout || MahjonggLayouts.standard144;

		// deep copy array...
		this.layout = $.extend(true, [], layout);
		this.tiles = o.tileset.tiles;
		this.tileTypes = o.tileset.tileTypes;
		this.layersColors = o.layersColors;

		for(var i=0; i<this.layout.length; i++) {
			this.layout[i].index = i;
			this.layout[i].tilesBelow = []
			this.layout[i].tilesAbove = []
			this.layout[i].tilesOnLeft = []
			this.layout[i].tilesOnRight = []
			this.layout[i].occupiedBy = null;
		}

		this.findAdjacentPositions();

		this.STATE = 0;
		this.firstSelectedPos = null;
		this.firstDelectedTile = null;
		this.secondSelectedPos = null;
		this.secondSelectedTile = null;

	},

	makeTileList: function() {
		var out = []
		for(var i=0; i<this.tileTypes.length; i++) {
			var tt = this.tiles[this.tileTypes[i]]
			for(var j=0; j<tt.icons.length; j++) {
				for(k=0; k<tt.countInSet; k++) {
					out.push({type:this.tileTypes[i], index: j, name: this.tileTypes[i]+(j+1)})
				}
			}
		}
		return out;
	},

	// find adjacencies...
	findAdjacentPositions: function() {
		for(var i=0; i<this.layout.length; i++) {
			var currentPos = this.layout[i]
			for(var j=0; j<this.layout.length; j++) {
				if(j != i) {
					var otherPos = this.layout[j]
					this.testAdjacency(currentPos, otherPos)
				}
			}
		}
	},

	testAdjacency: function(pos, otherPos) {
		// is other position below?
		if(otherPos.z+1 == pos.z && Math.abs(pos.x-otherPos.x)<=1 && Math.abs(pos.y-otherPos.y)<=1) {
			pos.tilesBelow.push(otherPos.index);
			otherPos.tilesAbove.push(pos.index);
		}
		if(otherPos.z == pos.z) {
			// is other position on the left?
			if(otherPos.x+2 == pos.x && Math.abs(pos.y-otherPos.y)<=1) {
				pos.tilesOnLeft.push(otherPos.index);
			}
			// is other position on the right?
			if(otherPos.x-2 == pos.x && Math.abs(pos.y-otherPos.y)<=1) {
				pos.tilesOnRight.push(otherPos.index);
			}
		}
	},
	renderBoard: function() {
	    console.log("Mahjongg.renderBoard")
		var tileList = this.makeTileList();

		var tmpArray = []
		var newTileList = []
		for(var i=0; i<72; i++) {
			tmpArray.push(i);
			newTileList.push(0);
			newTileList.push(0);
		}
		this.shuffle(tmpArray);
		// console.log(tmpArray);
		for(var i=0; i<72; i++) {
			var ind = tmpArray[i]
			newTileList[2*i] = tileList[2*ind];
			newTileList[2*i+1] = tileList[2*ind+1];
		}
		tileList = newTileList;


		// better placement algorithm:
		// - build a pile of Mahjongg tiles of the same type
		// - randomly remove pair-by-pair (they will always match)
		// - randomly assign tiles to the positions

		var tile1 = tileList[0];
		var tile2 = tileList[1];
		for(var i=0; i<72; i++) {
			this.occupyPosition(i*2, tile1);
			this.occupyPosition(i*2+1, tile2);
		}

		// solve the puzzle & record the positions
		var positions = [];
		while(true) {
			var canBeRemoved = [];
			var ndx = [];
			var j = 0;
			for(var i=0; i<144; i++) {
				if(this.canTileBeRemoved(i)) {
					canBeRemoved.push(i);
					ndx.push(j);
					j++;
				}
			}
			if(ndx.length>=2) {
				this.shuffle(ndx);
				var first = canBeRemoved[ndx[0]];
				var second = canBeRemoved[ndx[1]];
				positions.push(first);
				positions.push(second);
				this.clearPosition(first);
				this.clearPosition(second);
				// console.log(canBeRemoved, ndx, first, second);
			} else {
			    console.log("Generating the tile layout", ndx, positions.length);
				break;
			}
		}
		// console.log("Positions", positions);


		// fill the free positions...
		for(var i=0; i<72; i++) {
    		console.log("Fill free position", positions.length, 2*(71-i), 2*(71-i)+1);
			var tile1 = this.occupyPosition(positions[2*(71-i)], tileList[2*i]);
			var tile2 = this.occupyPosition(positions[2*(71-i)+1], tileList[2*i+1]);
			// TODO test if this pair can be also removed (the second tile is not on top of the first)
			var ok = this.canTileBeRemoved(tile1.index) && this.canTileBeRemoved(tile2.index);
			// console.log(i, tile1, tile2, ok);
		}

		// all tiles set!
		// console.log("All positions occupied!")
		// console.log(this.layout)

		this.tileList = tileList;
		var self = this;
		for(var i=0; i<this.layout.length; i++) {
			(function() {
				var pos = self.layout[i]
				var tile = pos.occupiedBy; // tileList[i]
				// drawTile(pos.x, pos.y, tile.name)
				var ttt = new MahjonggTileWidget(self, tile.type, tile.index, pos.x, pos.y, pos.z);
				var clk = ttt.clickable;
				clk.onClick(function() {
					self.onTileClicked(ttt, tile, pos);
				})
			})();

		}


		var occupiedPositions = {}
		var freePositions = {}
		var freePositionCount = 0
	},

	isPositionFree: function(index) {
		var pos = this.layout[index]
		if(pos.occupiedBy) return false;
		// is position valid?
		// position is valid if:
		//  - all positions below are occupied
		//  and
		// - row is empty (if we go as far as we can to the left/right, we encounter only empty positions)
		// or - we bave occupied all the left neighbors or all the right neighbors
		return this.areAllBelowPositionsOccupied(index) && (this.isRowEmpty(index) || this.areAllLeftPositionsOccupied(index) || this.areAllRightPositionsOccupied(index))
	},

	areAllBelowPositionsOccupied: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesBelow.length; i++) {
			var otherPos = this.layout[pos.tilesBelow[i]]
			if(!otherPos.occupiedBy) return false;
		}
		return true;
	},

	areAllAbovePositionsFree: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesAbove.length; i++) {
			var otherPos = this.layout[pos.tilesAbove[i]]
			if(otherPos.occupiedBy) return false;
		}
		return true;
	},

	areAllLeftPositionsOccupied: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesOnLeft.length; i++) {
			var otherPos = this.layout[pos.tilesOnLeft[i]]
			if(!otherPos.occupiedBy) return false;
		}
		return true;
	},

	areAllRightPositionsOccupied: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesOnRight.length; i++) {
			var otherPos = this.layout[pos.tilesOnRight[i]]
			if(!otherPos.occupiedBy) return false;
		}
		return true;
	},

	areAllLeftPositionsFree: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesOnLeft.length; i++) {
			var otherPos = this.layout[pos.tilesOnLeft[i]]
			if(otherPos.occupiedBy) return false;
		}
		return true;
	},

	areAllRightPositionsFree: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesOnRight.length; i++) {
			var otherPos = this.layout[pos.tilesOnRight[i]]
			if(otherPos.occupiedBy) return false;
		}
		return true;
	},

	isRowEmpty: function(index, direction) {
		var pos = this.layout[index]
		var out = !pos.occupiedBy
		if(out) {
			if(!direction || direction=="left") {
				for(var i=0; i<pos.tilesOnLeft.length; i++) {
					var otherPos = this.layout[pos.tilesOnLeft[i]]
					if(!this.isRowEmpty(otherPos.index, "left")) return false;
				}
			}
			if(!direction || direction=="right") {
				for(var i=0; i<pos.tilesOnRight.length; i++) {
					var otherPos = this.layout[pos.tilesOnRight[i]]
					if(!this.isRowEmpty(otherPos.index, "right")) return false;
				}
			}
		}
		return out;
	},

	testTilesIfMatching: function(tile1, tile2) {
		var tt1 = this.tiles[tile1.type];
		var tt2 = this.tiles[tile2.type];
		return (tile1.type == tile2.type) && (tt1.matchesWithAnother || (tile1.index == tile2.index));
	},

	occupyPosition: function(index, tile) {
	    // console.log("Occupy position:", index, tile);
		var pos = this.layout[index];
		pos.occupiedBy = tile;
		return { index: index, pos: pos, tile: tile };
	},

	clearPosition: function(index) {
		var pos = this.layout[index];
		pos.occupiedBy = null;
		return { index: index, pos: pos };
	},


	placeTile: function(tile) {
		// find free place
		var ind = Math.floor(Math.random()*144)
		while(!this.isPositionFree(ind)) {
			ind = ( ind + 1 ) % 144;
		}
		// found one!
		return this.occupyPosition(ind, tile);
	},

	// randomize tiles...
	shuffle: function(array) {
	  var currentIndex = array.length, temporaryValue, randomIndex ;

	  // While there remain elements to shuffle...
	  while (0 !== currentIndex) {

	    // Pick a remaining element...
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex -= 1;

	    // And swap it with the current element.
	    temporaryValue = array[currentIndex];
	    array[currentIndex] = array[randomIndex];
	    array[randomIndex] = temporaryValue;
	  }

	  return array;
	},

	canTileBeRemoved: function(index) {
		var pos = this.layout[index]
		var tile = pos.occupiedBy;
		if(!tile) return false;
		var leftFree = this.areAllLeftPositionsFree(index);
		var rightFree = this.areAllRightPositionsFree(index);
		var aboveFree = this.areAllAbovePositionsFree(index);
		var free = (leftFree || rightFree) && aboveFree;
		return free;
	},

	isBoardCleared: function() {
		for(var i=0; i<144; i++) {
			var pos = this.layout[i];
			if(pos.occupiedBy) return false;
		}
		return true;
	},

	getHints: function() {
		var hints = {};
		for(var i=0; i<144; i++) {
			if(this.canTileBeRemoved(i)) {
				var pos = this.layout[i];
				var name = pos.occupiedBy.name;
				if(!(name in hints)) {
					hints[name] = [];
				}
				hints[name].push(i);
			}
		}
		var hintArray = [];
		for(var key in hints) {
			if(hints[key].length < 2) {
				delete hints[key];
			} else {
				hintArray.push(hints[key]);
			}
		}
		return hintArray;
	},

	onTileClicked: function(tileDiv, tile, pos) {
		var self = this;
		// console.log("Tile clicked: ", tile, pos)
		// console.log("Free: "+this.canTileBeRemoved(pos.index));
		if(this.canTileBeRemoved(pos.index)) {
			// can remove tile...
			if(this.STATE == 0) {
				this.firstSelectedPos = pos;
				this.firstSelectedTile = tileDiv;
				tileDiv.setSelectedStyle();
				this.STATE = 1;
			} else if(this.STATE == 1) {
				if(pos.index == this.firstSelectedPos.index) {
					// we clicked on the same tile again...
					tileDiv.setDefaultStyle();
					this.firstSelectedPos = null;
					this.firstSelectedTile = null;
					this.STATE = 0;
				} else {
					// we clicked on another tile
					this.secondSelectedPos = pos;
					this.secondSelectedTile = tileDiv;
					tileDiv.setSelectedStyle();
					this.STATE = 2;
					if(this.testTilesIfMatching(this.firstSelectedPos.occupiedBy, this.secondSelectedPos.occupiedBy)) {
						// console.log("tiles do match!");
						setTimeout(function() {
							self.firstSelectedPos.occupiedBy = null;
							self.secondSelectedPos.occupiedBy = null;
							self.firstSelectedTile.clear();
							self.secondSelectedTile.clear();
							self.STATE = 0;
							var hints = self.getHints();
							console.log("Hints:", hints.length);
							if(hints.length == 0) {
								// console.log("Hints:", hints);
								if(self.isBoardCleared()) {
								    self.cleared = true;
									self.finish(true);
								} else {
									self.finish(false);
								}
							}
						}, self.highlightDuration);
					} else {
						// console.log("tiles don't match!");
						this.firstSelectedTile.setNonmatchedStyle();
						this.secondSelectedTile.setNonmatchedStyle();
						setTimeout(function() {
							self.firstSelectedTile.setDefaultStyle();
							self.secondSelectedTile.setDefaultStyle();
							self.firstSelectedTile.setDefaultStyle();
							self.secondSelectedTile.setDefaultStyle();
							self.STATE = 0;
						}, self.highlightDuration);
					}
				}
			}
		}
	},
    // set default embedding options for this Game
    getEmbeddingOptions: function() {
        return {
            renderTitle: false,
            renderAbortButton: true
        };
    },
    createGUI: function(r) {
        var self = this;
        this.body = new GroupWidget();
    },
    generateTaskData: function(options) {
        return null;
    },            
    renderFrame: function() {
        this.renderBoard();
    },    
    loadGamepackData: function() {
        var self = this;
        var name = self.meta.gamepackName;
        var dfd = jQuery.Deferred();
        var gamepackUrl = self.meta.appBaseUrl + "/gamepacks/" + name;
        var tilesetUrl = self.meta.appBaseUrl + "/"+ self.meta.res("tileset")
        $.getJSON(tilesetUrl).done(function(tileset) {
            console.log("Tileset data loaded:", tileset, tilesetUrl);
            // call resolve when it is done
            dfd.resolve({name:name, url:gamepackUrl, tilesetUrl: tilesetUrl, tileset:tileset});
        });
        return dfd.promise();
    },
    initializeTask: function() {
        this.task = new NullTask();
        this.answer = null;
        this.tilesetBaseUrl = dirname(this.gamepack.tilesetUrl);
        console.log("Mahjongg.initializeTask", this.tilesetBaseUrl);
    },
    generateReport: function(evalResult) {
        return [
            this.cleared ? this.loc("All pairs found!") : this.loc("No more moves left!"),
            this.loc("Total time") + ": " + (this.currentTime / 1000) + " s"
        ];
    },
    update: function(elapsedMillis) {
    }
},{
});
